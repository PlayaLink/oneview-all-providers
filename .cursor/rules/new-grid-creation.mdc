---
description: Automated workflow for creating new grids in the OneView All Providers app. This rule handles the complete process from screenshot analysis to full grid implementation including database migrations, seeding scripts, frontend configuration, and semantic markup.
globs:
alwaysApply: true
---

# Grid Creation Automation Rule

When I ask you to create a new grid for the OneView All Providers app, follow this comprehensive workflow:

## Phase 1: Screenshot Analysis & Information Gathering

### Step 1: Analyze Screenshots
When I provide screenshots of the grid I want to replicate:
- Analyze the grid columns and their display names
- **Identify field grouping patterns** for the Details panel (see Field Grouping Patterns below)
- Determine appropriate data types for each field
- Identify which columns should be visible by default
- Determine logical field ordering
- Identify appropriate field groups for the Details panel
- Determine which actions should be available for this grid type
- **Extract dropdown/select options** from any dropdown fields visible in the screenshots
- **Identify field validation rules** and constraints from the UI

### Field Grouping Patterns
Based on the screenshot analysis, determine which pattern to use:

**Pattern 1: CollapsibleSection Pattern**
- **When to use**: Screenshots show fields grouped under clear section headers (e.g., "PROVIDER NAME", "TYPE, SPECIALTY & CLASSIFICATIONS", "CONTACT INFO")
- **Characteristics**: Multiple sections with uppercase, bold headers that group related fields together
- **Implementation**: Use `CollapsibleSection.tsx` component to wrap field groups
- **Example**: Provider Info Details components

**Pattern 2: Simple Field List Pattern**
- **When to use**: Screenshots show fields without section headers, just individual fields listed
- **Characteristics**: No grouping headers, fields are simply listed vertically or in a grid layout
- **Implementation**: Render fields directly without CollapsibleSection wrapper
- **Layout**: 
  - Sidepanel context: Vertical list
  - Modal context: Use grid layout as shown in screenshot
- **Example**: Birth Info Details components

**Pattern 3: SearchCriteriaSection Pattern**
- **When to use**: Screenshots show a "SEARCH CRITERIA" section with specific styling and layout
- **Characteristics**: Distinct "SEARCH CRITERIA" header with fields arranged in a specific grid pattern
- **Implementation**: Use `SearchCriteriaSection.tsx` component for the search criteria fields
- **Additional sections**: May have other sections (like "ADDITIONAL INFO") that can use CollapsibleSection or simple field list
- **Example**: State License Details components

### Step 2: Generate Required Input Information
Based on the screenshot analysis, I will generate a structured list of required information:

**Grid Configuration:**
- **Grid Name**: [Display name from screenshot]
- **Table Name**: [Suggested snake_case table name]
- **Grid Group**: [Suggested section/group]
- **Icon**: [Suggested FontAwesome icon name in kebab-case format, e.g., "house-chimney-user" for faHouseChimneyUser]
- **Order**: [What order should this grid appear in within its group?]
- **Grid Key**: [MUST use underscores, e.g., "state_controlled_substance_licenses" NOT "state-controlled-substance-licenses"]

**Fields Array:**
```javascript
[
  {
    "name": "field_name",
    "display_name": "Display Name",
    "type": "text|number|boolean|date|email|url|phone|single-select|multi-select|file|oneview_record",
    "order": 1,
    "visible": true|false,
    "group": "field_group_name",
    "description": "Field description",
    "options": ["option1", "option2", "option3"] // For single-select/multi-select fields
  }
]
```

**Field Groups Array:**
```javascript
[
  {
    "id": "group_id",
    "title": "Group Title",
    "fields": ["field1", "field2", "field3"]
  }
]
```

**Actions Array:**
```javascript
["download", "flag", "side_panel", "view_details"]
```

**Available Actions (Database Reference):**
The following actions are currently defined in the database and available for use in grid configurations:

**Core Actions:**
- `activate` - Activate record
- `alert` - Toggle alerts for this record
- `deactivate` - Deactivate record
- `download` - Download record data
- `exclude` - Exclude from processing
- `flag` - Flag this record
- `side_panel` - Open side panel view
- `tracking` - Track this record
- `verifications` - Manage verifications
- `view_details` - View detailed information

**IMPORTANT**: When analyzing screenshots, only use action names from the list above. These are the only valid actions available in the system.

### Step 3: Confirmation Step
**CRITICAL**: Before proceeding with the automated workflow, I will:
1. Present the generated information in a clear, structured format
2. Ask you to review and confirm each section
3. Allow you to modify any field names, types, groupings, or actions
4. Only proceed to Phase 2 after you explicitly confirm the information is correct

## Phase 2: Automated Workflow (Only After Confirmation)

**IMPORTANT**: This workflow creates grids without authentication requirements for easier development and testing. All database operations will work without user authentication.

**CRITICAL DATABASE SCHEMA NOTES**:
- Always reference the actual database schema before writing SQL
- `grid_definitions` table columns: `id`, `key`, `display_name`, `table_name`, `"group"`, `icon`, `description`, `default_visible`, `section_id`, `"order"`
- `grid_columns` table columns: `id`, `grid_id`, `name`, `display_name`, `type`, `"order"`, `visible`, `width`, `options`, `required`, `"group"`, `description`
- `grid_actions` table columns: `id`, `grid_id`, `action_id`, `"order"`, `created_at`, `updated_at`
- **NEVER** assume column names - always verify against the actual schema

### 1. Create Database Migration
- Generate SQL migration file: `supabase/migrations/create_{table_name}_table.sql`
- Include standard fields: id (uuid), provider_id (uuid), created_at, updated_at
- Add all confirmed fields with appropriate data types
- Include foreign key constraint to providers table
- Add index on provider_id for performance
- Include tags field as text[] array
- Add last_updated timestamp field
- **ALWAYS** provide raw SQL scripts instead of using Supabase CLI
- **ALWAYS** include debugging queries and orphaned record checks
- **ALWAYS** add proper indexes on foreign keys for performance
- **ALWAYS** include foreign key constraints and validation rules
- **ALWAYS** test migrations with sample data and validation queries
- **NEVER** include RLS policies or authentication requirements - disable RLS for development
- **ALWAYS** use `ALTER TABLE ... DISABLE ROW LEVEL SECURITY` for easier development/testing
- **CRITICAL**: Use correct database column names - `display_name` NOT `grid_name`, `"group"` NOT `grid_group`, `"order"` NOT `display_order`

### 2. Create Provider View
- Generate SQL migration file: `supabase/migrations/create_{table_name}_with_provider_view.sql`
- Create view that joins the new table with `providers_with_full_name` table
- Include provider data: `provider_name`, `title`, `primary_specialty`
- Update `grid_definitions` table to use the new view instead of raw table
- Follow the established pattern from existing grids (addresses_with_provider, state_licenses_with_provider, etc.)
- **ALWAYS** use LEFT JOIN to ensure all records are included even if provider data is missing
- **ALWAYS** update grid_definitions.table_name to point to the new view
- **ALWAYS** include verification query to confirm the update
- **ALWAYS** provide raw SQL scripts instead of using Supabase CLI
- **ALWAYS** grant permissions to `public` instead of `authenticated` for development
- **NEVER** include authentication requirements for view access

### 3. Create Seeding Script
- Generate TypeScript seeding script: `scripts/seed-{table_name}.ts`
- Import dropdown options from `{GridName}SelectInputOptions.ts`
- Use imported options for consistent data generation
- Use faker.js for realistic dummy data generation
- Include deterministic data generation using seed values
- Generate 3-5 records per provider
- **ALWAYS** include comprehensive error handling with try-catch blocks
- **ALWAYS** use batch processing (batch size 100) for large data inserts
- **ALWAYS** clear existing data before seeding to avoid conflicts
- **ALWAYS** use faker.seed() for deterministic test data generation
- **ALWAYS** include proper process.exit codes (0 for success, 1 for failure)
- **ALWAYS** use custom fetch configuration for SSL certificate handling in development
- **ALWAYS** import dropdown options from SelectInputOptions files for consistency

### 4. Add Supabase Client Functions
- Add Zod schema for type validation in `src/lib/supabaseClient.ts`
- Add CRUD helper functions: fetch{TableName}, insert{TableName}, update{TableName}, delete{TableName}
- Include proper error handling and type safety
- **ALWAYS** use Zod schemas for database operation validation
- **ALWAYS** define proper TypeScript interfaces for all data structures
- **ALWAYS** use generic functions for reusable database operations
- **ALWAYS** validate data types before database operations
- **ALWAYS** convert technical errors to user-friendly messages
- **ALWAYS** implement rollback mechanisms for optimistic updates
- **ALWAYS** use toast notifications for consistent error feedback
- **ALWAYS** include proper error logging with context information
- **NEVER** include RLS policy violation handling since RLS is disabled

### 5. Create Grid Configuration
- Generate SQL script to insert grid definition into `grid_definitions` table
- Generate SQL script to insert all columns into `grid_columns` table
- Include proper ordering, visibility, and grouping
- Set appropriate column widths and types
- **CRITICAL**: Use correct database schema column names:
  - `grid_definitions` table: `key`, `display_name`, `table_name`, `"group"`, `icon`, `"order"`
  - `grid_columns` table: `grid_id`, `name`, `display_name`, `type`, `"order"`, `visible`, `width`, `"group"`
  - **NEVER** use: `grid_name`, `grid_group`, `display_order`, `field_name`, `data_type`, `order_index`, `group_name`
- **CRITICAL**: Store icon in kebab-case format (e.g., "house-chimney-user") NOT FontAwesome format (e.g., "faHouseChimneyUser")
- **CRITICAL**: Grid key consistency - ALWAYS use underscores in grid keys (e.g., "state_controlled_substance_licenses") NOT hyphens (e.g., "state-controlled-substance-licenses")
  - Database `grid_definitions.key` must match template configuration key exactly
  - Template configuration uses underscores: `case "state_controlled_substance_licenses"`
  - Database must use same format: `key = 'state_controlled_substance_licenses'`
  - **EXAMPLE**: `additional_names` ✅, `state_controlled_substance_licenses` ✅, `dea_licenses` ✅

### 6. Create Grid Actions Configuration
- Generate SQL script to link grid with specified actions in `grid_actions` table
- Use helper functions to get grid_id and action_id by name
- Include proper ordering for actions

### 7. Create Complete Database Script
- Generate comprehensive SQL script: `scripts/create-{table_name}-complete.sql`
- Combine all database operations into a single executable script
- Include all steps: table creation, provider view, grid configuration, and actions setup
- Add comprehensive verification queries at the end
- Include proper error handling and rollback mechanisms
- Add completion message with success indicators
- **ALWAYS** make the script idempotent (can be run multiple times safely)
- **ALWAYS** include debugging queries to verify each step
- **ALWAYS** use proper variable declarations and error handling in PL/pgSQL blocks
- **ALWAYS** include sample data insertion and cleanup for testing
- **ALWAYS** provide clear section headers with `-- ============================================================================` dividers

**Complete Database Script Template Structure:**
```sql
-- Complete {GridName} Grid Creation Script (No Auth Required)
-- This script creates the entire grid system in one go
-- Run this single script to set up everything

-- ============================================================================
-- 1. CREATE TABLE
-- ============================================================================
-- [Table creation with indexes, triggers, RLS disabled]

-- ============================================================================
-- 2. CREATE PROVIDER VIEW
-- ============================================================================
-- [Provider view creation with public permissions]

-- ============================================================================
-- 3. SETUP GRID DEFINITION AND COLUMNS
-- ============================================================================
-- [Grid definition insertion and column configuration]

-- ============================================================================
-- 4. SETUP GRID ACTIONS
-- ============================================================================
-- [Grid actions linking with proper ordering]

-- ============================================================================
-- 5. VERIFICATION QUERIES
-- ============================================================================
-- [Comprehensive verification of all components]

-- ============================================================================
-- COMPLETION MESSAGE
-- ============================================================================
-- [Success indicators and completion notice]
```

### 8. Create SelectInputOptions File
- Generate `{GridName}SelectInputOptions.ts` file in `src/components/grid-item-details/`
- Export all dropdown options as named constants (e.g., `STATE_OPTIONS`, `STATUS_OPTIONS`, `YES_NO_OPTIONS`)
- Include both simple options for forms and extended options for seeding scripts
- Use descriptive constant names that match the field purpose
- Include TypeScript comments explaining the purpose of each option set

### 9. Create Details Components
- Generate `{GridName}Details.tsx` component in `src/components/grid-item-details/`
- Generate `{GridName}DetailsWide.tsx` component in `src/components/grid-item-details/`
- Import dropdown options from `{GridName}SelectInputOptions.ts`
- Include all fields with appropriate input types (text, select, date, etc.)
- Use imported options for single-select and multi-select fields
- Include proper form validation and error handling
- Add semantic markup with `data-testid` attributes
- **Apply the correct field grouping pattern** based on screenshot analysis:
  - **Pattern 1 (CollapsibleSection)**: Wrap field groups in `CollapsibleSection` components
  - **Pattern 2 (Simple Field List)**: Render fields directly, use grid layout for wide modal
  - **Pattern 3 (SearchCriteriaSection)**: Use `SearchCriteriaSection` for search criteria, CollapsibleSection for other groups
- Include proper TypeScript interfaces
- Export template objects for both components (e.g., `{gridName}Template` and `{gridName}WideTemplate`)
- **ALWAYS** add comprehensive ARIA support: role, aria-label, aria-labelledby, aria-expanded attributes
- **ALWAYS** use semantic HTML elements (nav, main, aside, header, footer, section)
- **ALWAYS** support keyboard navigation (Enter/Space keys) in interactive elements
- **ALWAYS** add data-testid attributes for DOM inspection and testing
- **ALWAYS** include aria-hidden="true" for decorative icons

### 10. Update Template Configuration
- Add new grid to `gridToTemplateMap` in `src/lib/templateConfigs.ts`
- Import both template objects from the Details components
- Add case in `getTemplateConfigByGrid` function to handle context switching
- Implement `getDetailsComponent` function for modal vs sidepanel context
- Create template configuration with field groups for Details panel
- Include proper tab configuration (Details, Notes, Documents, History)
- Use CollapsibleSection for field groups
- **CRITICAL**: Grid key consistency - Use underscores in template configuration keys
  - Template case must match database key exactly: `case "state_controlled_substance_licenses"`
  - Database key must use underscores: `key = 'state_controlled_substance_licenses'`
  - **NEVER** use hyphens in grid keys: `"state-controlled-substance-licenses"` ❌



## File Naming Conventions
- Migration files: `create_{table_name}_table.sql`
- Provider view files: `create_{table_name}_with_provider_view.sql`
- Seeding scripts: `seed-{table_name}.ts`
- Grid config scripts: `setup-{table_name}-grid.sql`
- Actions config scripts: `setup-{table_name}-actions.sql`
- Complete database script: `create-{table_name}-complete.sql`
- SelectInputOptions file: `{GridName}SelectInputOptions.ts`
- Details components: `{GridName}Details.tsx` and `{GridName}DetailsWide.tsx`

## Database Schema Patterns
- All grids must include `provider_id` foreign key to providers table
- Use `uuid` for primary keys with `gen_random_uuid()`
- Include `created_at` and `updated_at` timestamps
- Use `text[]` for tags fields
- Include `last_updated` timestamp field
- Add proper indexes for performance

## Grid Actions Mapping
Available actions: download, attachment, notification, side_panel, flag, delete, toggle, star, verified, view_details

## Field Types
Supported types: text, number, boolean, date, email, url, phone, single-select, multi-select, file, oneview_record

## Context-Aware Component Pattern
The rule follows the established pattern for context-aware components:
- **Sidepanel Context**: Uses `{GridName}Details.tsx` component
- **Modal Context**: Uses `{GridName}DetailsWide.tsx` component
- **Template Configuration**: Implements `getDetailsComponent` function to switch between contexts
- **Import Pattern**: Both template objects are imported and used in `templateConfigs.ts`

## Field Grouping Implementation Patterns
Based on screenshot analysis, implement the appropriate pattern:

**Pattern 1: CollapsibleSection Implementation**
```tsx
// For grids with section headers like "PROVIDER NAME", "CONTACT INFO"
<CollapsibleSection title="Provider Name">
  {providerNameFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
<CollapsibleSection title="Contact Info">
  {contactFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
```

**Pattern 2: Simple Field List Implementation**
```tsx
// For grids without section headers, just individual fields
<div className="flex flex-col gap-4 self-stretch">
  {fields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</div>

// For wide modal context, use grid layout as shown in screenshot
<div className="grid grid-cols-2 gap-4">
  {fields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</div>
```

**Pattern 3: SearchCriteriaSection Implementation**
```tsx
// For grids with "SEARCH CRITERIA" section
<SearchCriteriaSection 
  title="Search Criteria"
  fields={searchCriteriaFields}
  formValues={formValues}
  handleChange={handleChange}
  provider={provider}
/>
<CollapsibleSection title="Additional Info">
  {additionalFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
```

## SelectInputOptions Pattern
The rule follows the established pattern for managing dropdown options:
- **Single Source of Truth**: All dropdown options stored in `{GridName}SelectInputOptions.ts`
- **Performance Benefits**: No database queries for dropdown options (hardcoded)
- **DRY Principle**: No duplication between Details and DetailsWide components
- **Seeding Consistency**: Same options used in seeding scripts for realistic data
- **Easy Maintenance**: Change options in one place, updates everywhere
- **Type Safety**: Exported TypeScript constants with descriptive names

## Example Workflow
1. **You provide**: Screenshots of the grid to replicate
2. **I analyze**: Screenshots and generate structured information
3. **You review**: Generated information and make any necessary changes
4. **You confirm**: Information is correct and ready to proceed
5. **I execute**: Complete automated workflow to create the grid

## Confirmation Template
When presenting information for confirmation, I will use this format:

```
## Grid Configuration Review

**Grid Name**: [Name]
**Table Name**: [table_name]
**Grid Group**: [group]
**Icon**: [icon_name]
**Order**: [order_number]
**Grid Key**: [grid_key_with_underscores]

## Fields Configuration
[Structured list of all fields]

## Field Groups Configuration  
[Structured list of field groups]

## Actions Configuration
[Array of actions]

**Please review the above information and confirm if it's correct, or let me know what changes you'd like me to make before proceeding with the automated workflow.**
```

This rule ensures accuracy by requiring explicit confirmation before proceeding with the automated workflow, while still maintaining the efficiency of the automated process once confirmed.

## Best Practices from Recent Bug Fixes

### Grid Key Consistency Standards
- **ALWAYS** use underscores in grid keys: `state_controlled_substance_licenses` ✅
- **NEVER** use hyphens in grid keys: `state-controlled-substance-licenses` ❌
- **CRITICAL**: Database `grid_definitions.key` must match template configuration key exactly
- **VERIFY**: Check that `gridToTemplateMap` and `getTemplateConfigByGrid` use same key format
- **COMMON MISTAKE**: Hyphens vs underscores mismatch causes "No fields in Details panel" error

### Seeding Script Standards
- **ALWAYS** include comprehensive error handling with try-catch blocks
- **ALWAYS** use batch processing (batch size 100) for large data inserts
- **ALWAYS** clear existing data before seeding to avoid conflicts
- **ALWAYS** use faker.seed() for deterministic test data generation
- **ALWAYS** include proper process.exit codes (0 for success, 1 for failure)
- **ALWAYS** use custom fetch configuration for SSL certificate handling in development
- **ALWAYS** import dropdown options from SelectInputOptions files for consistency

### Database Migration Standards
- **ALWAYS** provide raw SQL scripts instead of using Supabase CLI
- **ALWAYS** include debugging queries and orphaned record checks
- **ALWAYS** add proper indexes on foreign keys for performance
- **ALWAYS** include foreign key constraints and validation rules
- **ALWAYS** test migrations with sample data and validation queries

### Feature Flag Implementation
- **ALWAYS** use boolean-based feature flags instead of string-based
- **ALWAYS** implement proper loading states and error handling
- **ALWAYS** use React Query for feature flag management with caching
- **ALWAYS** provide graceful fallbacks when feature flags fail to load
- **ALWAYS** define feature flags in TypeScript interfaces for type safety

### Error Handling Standards
- **ALWAYS** convert technical errors to user-friendly messages
- **ALWAYS** implement rollback mechanisms for optimistic updates
- **ALWAYS** handle RLS policy violations with specific error messages
- **ALWAYS** use toast notifications for consistent error feedback
- **ALWAYS** include proper error logging with context information

### Type Safety Requirements
- **ALWAYS** use Zod schemas for database operation validation
- **ALWAYS** define proper TypeScript interfaces for all data structures
- **ALWAYS** use generic functions for reusable database operations
- **ALWAYS** validate data types before database operations

### Accessibility and Semantic Markup Standards
- **ALWAYS** add comprehensive ARIA support: role, aria-label, aria-labelledby, aria-expanded attributes
- **ALWAYS** use semantic HTML elements (nav, main, aside, header, footer, section)
- **ALWAYS** support keyboard navigation (Enter/Space keys) in interactive elements
- **ALWAYS** add data-testid attributes for DOM inspection and testing
- **ALWAYS** include aria-hidden="true" for decorative icons

### Icon Mapping Standards
- **ALWAYS** add new grid icons to `src/lib/iconMapping.ts` file
- **ALWAYS** use FontAwesome icons from `@fortawesome/free-solid-svg-icons` package
- **ALWAYS** import the icon at the top of the `iconMapping.ts` file
- **ALWAYS** add the icon mapping to the `iconMap` object with kebab-case naming
- **ALWAYS** provide fallback to `faTable` if icon not found
- **ALWAYS** test icon rendering in the grid header after adding to mapping

### Icon Storage in Database
- **CRITICAL**: Store icons in `grid_definitions.icon` column using **kebab-case format** (e.g., "house-chimney-user")
- **NEVER** store FontAwesome format (e.g., "faHouseChimneyUser") in the database
- **ALWAYS** convert FontAwesome icon names to kebab-case when inserting into grid_definitions table
- **EXAMPLE**: faHouseChimneyUser → "house-chimney-user", faUserDoctor → "user-doctor", faFileMedical → "file-medical"