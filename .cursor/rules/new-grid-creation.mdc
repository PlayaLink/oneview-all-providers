---
description: Automated workflow for creating new grids in the OneView All Providers app. This rule handles the complete process from screenshot analysis to full grid implementation including database migrations, seeding scripts, frontend configuration, and semantic markup.
globs:
alwaysApply: true
---

# Grid Creation Automation Rule

When I ask you to create a new grid for the OneView All Providers app, follow this comprehensive workflow:

## Phase 1: Screenshot Analysis & Information Gathering

### Step 1: Analyze Screenshots
When I provide screenshots of the grid I want to replicate:
- Analyze the grid columns and their display names
- **Identify field grouping patterns** for the Details panel (see Field Grouping Patterns below)
- Determine appropriate data types for each field
- Identify which columns should be visible by default
- Determine logical field ordering
- Identify appropriate field groups for the Details panel
- Determine which actions should be available for this grid type
- **Extract dropdown/select options** from any dropdown fields visible in the screenshots
- **Identify field validation rules** and constraints from the UI

### Field Grouping Patterns
Based on the screenshot analysis, determine which pattern to use:

**Pattern 1: CollapsibleSection Pattern**
- **When to use**: Screenshots show fields grouped under clear section headers (e.g., "PROVIDER NAME", "TYPE, SPECIALTY & CLASSIFICATIONS", "CONTACT INFO")
- **Characteristics**: Multiple sections with uppercase, bold headers that group related fields together
- **Implementation**: Use `CollapsibleSection.tsx` component to wrap field groups
- **Example**: Provider Info Details components

**Pattern 2: Simple Field List Pattern**
- **When to use**: Screenshots show fields without section headers, just individual fields listed
- **Characteristics**: No grouping headers, fields are simply listed vertically or in a grid layout
- **Implementation**: Render fields directly without CollapsibleSection wrapper
- **Layout**: 
  - Sidepanel context: Vertical list
  - Modal context: Use grid layout as shown in screenshot
- **Example**: Birth Info Details components

**Pattern 3: SearchCriteriaSection Pattern**
- **When to use**: Screenshots show a "SEARCH CRITERIA" section with specific styling and layout
- **Characteristics**: Distinct "SEARCH CRITERIA" header with fields arranged in a specific grid pattern
- **Implementation**: Use `SearchCriteriaSection.tsx` component for the search criteria fields
- **Additional sections**: May have other sections (like "ADDITIONAL INFO") that can use CollapsibleSection or simple field list
- **Example**: State License Details components

### Step 2: Generate Required Input Information
Based on the screenshot analysis, I will generate a structured list of required information:

**Grid Configuration:**
- **Grid Name**: [Display name from screenshot]
- **Table Name**: [Suggested snake_case table name]
- **Grid Group**: [Suggested section/group]
- **Icon**: [Suggested FontAwesome icon name]

**Fields Array:**
```javascript
[
  {
    "name": "field_name",
    "display_name": "Display Name",
    "type": "text|number|boolean|date|email|url|phone|single-select|multi-select|file|oneview_record",
    "order": 1,
    "visible": true|false,
    "group": "field_group_name",
    "description": "Field description",
    "options": ["option1", "option2", "option3"] // For single-select/multi-select fields
  }
]
```

**Field Groups Array:**
```javascript
[
  {
    "id": "group_id",
    "title": "Group Title",
    "fields": ["field1", "field2", "field3"]
  }
]
```

**Actions Array:**
```javascript
["download", "flag", "side_panel", "view_details"]
```

### Step 3: Confirmation Step
**CRITICAL**: Before proceeding with the automated workflow, I will:
1. Present the generated information in a clear, structured format
2. Ask you to review and confirm each section
3. Allow you to modify any field names, types, groupings, or actions
4. Only proceed to Phase 2 after you explicitly confirm the information is correct

## Phase 2: Automated Workflow (Only After Confirmation)

### 1. Create Database Migration
- Generate SQL migration file: `supabase/migrations/create_{table_name}_table.sql`
- Include standard fields: id (uuid), provider_id (uuid), created_at, updated_at
- Add all confirmed fields with appropriate data types
- Include foreign key constraint to providers table
- Add index on provider_id for performance
- Include tags field as text[] array
- Add last_updated timestamp field
- **ALWAYS** provide raw SQL scripts instead of using Supabase CLI
- **ALWAYS** include debugging queries and orphaned record checks
- **ALWAYS** add proper indexes on foreign keys for performance
- **ALWAYS** include foreign key constraints and validation rules
- **ALWAYS** test migrations with sample data and validation queries

### 2. Create Seeding Script
- Generate TypeScript seeding script: `scripts/seed-{table_name}.ts`
- Import dropdown options from `{GridName}SelectInputOptions.ts`
- Use imported options for consistent data generation
- Use faker.js for realistic dummy data generation
- Include deterministic data generation using seed values
- Generate 3-5 records per provider
- **ALWAYS** include comprehensive error handling with try-catch blocks
- **ALWAYS** use batch processing (batch size 100) for large data inserts
- **ALWAYS** clear existing data before seeding to avoid conflicts
- **ALWAYS** use faker.seed() for deterministic test data generation
- **ALWAYS** include proper process.exit codes (0 for success, 1 for failure)
- **ALWAYS** use custom fetch configuration for SSL certificate handling in development
- **ALWAYS** import dropdown options from SelectInputOptions files for consistency

### 3. Add Supabase Client Functions
- Add Zod schema for type validation in `src/lib/supabaseClient.ts`
- Add CRUD helper functions: fetch{TableName}, insert{TableName}, update{TableName}, delete{TableName}
- Include proper error handling and type safety
- **ALWAYS** use Zod schemas for database operation validation
- **ALWAYS** define proper TypeScript interfaces for all data structures
- **ALWAYS** use generic functions for reusable database operations
- **ALWAYS** validate data types before database operations
- **ALWAYS** convert technical errors to user-friendly messages
- **ALWAYS** implement rollback mechanisms for optimistic updates
- **ALWAYS** handle RLS policy violations with specific error messages
- **ALWAYS** use toast notifications for consistent error feedback
- **ALWAYS** include proper error logging with context information

### 4. Create Grid Configuration
- Generate SQL script to insert grid definition into `grid_definitions` table
- Generate SQL script to insert all columns into `grid_columns` table
- Include proper ordering, visibility, and grouping
- Set appropriate column widths and types

### 5. Create Grid Actions Configuration
- Generate SQL script to link grid with specified actions in `grid_actions` table
- Use helper functions to get grid_id and action_id by name
- Include proper ordering for actions

### 6. Create SelectInputOptions File
- Generate `{GridName}SelectInputOptions.ts` file in `src/components/grid-item-details/`
- Export all dropdown options as named constants (e.g., `STATE_OPTIONS`, `STATUS_OPTIONS`, `YES_NO_OPTIONS`)
- Include both simple options for forms and extended options for seeding scripts
- Use descriptive constant names that match the field purpose
- Include TypeScript comments explaining the purpose of each option set

### 7. Create Details Components
- Generate `{GridName}Details.tsx` component in `src/components/grid-item-details/`
- Generate `{GridName}DetailsWide.tsx` component in `src/components/grid-item-details/`
- Import dropdown options from `{GridName}SelectInputOptions.ts`
- Include all fields with appropriate input types (text, select, date, etc.)
- Use imported options for single-select and multi-select fields
- Include proper form validation and error handling
- Add semantic markup with `data-testid` attributes
- **Apply the correct field grouping pattern** based on screenshot analysis:
  - **Pattern 1 (CollapsibleSection)**: Wrap field groups in `CollapsibleSection` components
  - **Pattern 2 (Simple Field List)**: Render fields directly, use grid layout for wide modal
  - **Pattern 3 (SearchCriteriaSection)**: Use `SearchCriteriaSection` for search criteria, CollapsibleSection for other groups
- Include proper TypeScript interfaces
- Export template objects for both components (e.g., `{gridName}Template` and `{gridName}WideTemplate`)
- **ALWAYS** add comprehensive ARIA support: role, aria-label, aria-labelledby, aria-expanded attributes
- **ALWAYS** use semantic HTML elements (nav, main, aside, header, footer, section)
- **ALWAYS** support keyboard navigation (Enter/Space keys) in interactive elements
- **ALWAYS** add data-testid attributes for DOM inspection and testing
- **ALWAYS** include aria-hidden="true" for decorative icons

### 8. Update Template Configuration
- Add new grid to `gridToTemplateMap` in `src/lib/templateConfigs.ts`
- Import both template objects from the Details components
- Add case in `getTemplateConfigByGrid` function to handle context switching
- Implement `getDetailsComponent` function for modal vs sidepanel context
- Create template configuration with field groups for Details panel
- Include proper tab configuration (Details, Notes, Documents, History)
- Use CollapsibleSection for field groups

### 9. Add Semantic Markup
- Ensure all generated components include:
  - `data-testid` attributes with descriptive, hyphenated names
  - `role` attributes for accessibility
  - `aria-*` attributes as appropriate
  - Semantic HTML elements (section, main, aside, etc.)

## File Naming Conventions
- Migration files: `create_{table_name}_table.sql`
- Seeding scripts: `seed-{table_name}.ts`
- Grid config scripts: `setup-{table_name}-grid.sql`
- Actions config scripts: `setup-{table_name}-actions.sql`
- SelectInputOptions file: `{GridName}SelectInputOptions.ts`
- Details components: `{GridName}Details.tsx` and `{GridName}DetailsWide.tsx`

## Database Schema Patterns
- All grids must include `provider_id` foreign key to providers table
- Use `uuid` for primary keys with `gen_random_uuid()`
- Include `created_at` and `updated_at` timestamps
- Use `text[]` for tags fields
- Include `last_updated` timestamp field
- Add proper indexes for performance

## Grid Actions Mapping
Available actions: download, attachment, notification, side_panel, flag, delete, toggle, star, verified, view_details

## Field Types
Supported types: text, number, boolean, date, email, url, phone, single-select, multi-select, file, oneview_record

## Context-Aware Component Pattern
The rule follows the established pattern for context-aware components:
- **Sidepanel Context**: Uses `{GridName}Details.tsx` component
- **Modal Context**: Uses `{GridName}DetailsWide.tsx` component
- **Template Configuration**: Implements `getDetailsComponent` function to switch between contexts
- **Import Pattern**: Both template objects are imported and used in `templateConfigs.ts`

## Field Grouping Implementation Patterns
Based on screenshot analysis, implement the appropriate pattern:

**Pattern 1: CollapsibleSection Implementation**
```tsx
// For grids with section headers like "PROVIDER NAME", "CONTACT INFO"
<CollapsibleSection title="Provider Name">
  {providerNameFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
<CollapsibleSection title="Contact Info">
  {contactFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
```

**Pattern 2: Simple Field List Implementation**
```tsx
// For grids without section headers, just individual fields
<div className="flex flex-col gap-4 self-stretch">
  {fields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</div>

// For wide modal context, use grid layout as shown in screenshot
<div className="grid grid-cols-2 gap-4">
  {fields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</div>
```

**Pattern 3: SearchCriteriaSection Implementation**
```tsx
// For grids with "SEARCH CRITERIA" section
<SearchCriteriaSection 
  title="Search Criteria"
  fields={searchCriteriaFields}
  formValues={formValues}
  handleChange={handleChange}
  provider={provider}
/>
<CollapsibleSection title="Additional Info">
  {additionalFields.map(field => renderFieldComponent({ field, formValues, handleChange }))}
</CollapsibleSection>
```

## SelectInputOptions Pattern
The rule follows the established pattern for managing dropdown options:
- **Single Source of Truth**: All dropdown options stored in `{GridName}SelectInputOptions.ts`
- **Performance Benefits**: No database queries for dropdown options (hardcoded)
- **DRY Principle**: No duplication between Details and DetailsWide components
- **Seeding Consistency**: Same options used in seeding scripts for realistic data
- **Easy Maintenance**: Change options in one place, updates everywhere
- **Type Safety**: Exported TypeScript constants with descriptive names

## Example Workflow
1. **You provide**: Screenshots of the grid to replicate
2. **I analyze**: Screenshots and generate structured information
3. **You review**: Generated information and make any necessary changes
4. **You confirm**: Information is correct and ready to proceed
5. **I execute**: Complete automated workflow to create the grid

## Confirmation Template
When presenting information for confirmation, I will use this format:

```
## Grid Configuration Review

**Grid Name**: [Name]
**Table Name**: [table_name]
**Grid Group**: [group]
**Icon**: [icon_name]

## Fields Configuration
[Structured list of all fields]

## Field Groups Configuration  
[Structured list of field groups]

## Actions Configuration
[Array of actions]

**Please review the above information and confirm if it's correct, or let me know what changes you'd like me to make before proceeding with the automated workflow.**
```

This rule ensures accuracy by requiring explicit confirmation before proceeding with the automated workflow, while still maintaining the efficiency of the automated process once confirmed.

## Best Practices from Recent Bug Fixes

### Seeding Script Standards
- **ALWAYS** include comprehensive error handling with try-catch blocks
- **ALWAYS** use batch processing (batch size 100) for large data inserts
- **ALWAYS** clear existing data before seeding to avoid conflicts
- **ALWAYS** use faker.seed() for deterministic test data generation
- **ALWAYS** include proper process.exit codes (0 for success, 1 for failure)
- **ALWAYS** use custom fetch configuration for SSL certificate handling in development
- **ALWAYS** import dropdown options from SelectInputOptions files for consistency

### Database Migration Standards
- **ALWAYS** provide raw SQL scripts instead of using Supabase CLI
- **ALWAYS** include debugging queries and orphaned record checks
- **ALWAYS** add proper indexes on foreign keys for performance
- **ALWAYS** include foreign key constraints and validation rules
- **ALWAYS** test migrations with sample data and validation queries

### Feature Flag Implementation
- **ALWAYS** use boolean-based feature flags instead of string-based
- **ALWAYS** implement proper loading states and error handling
- **ALWAYS** use React Query for feature flag management with caching
- **ALWAYS** provide graceful fallbacks when feature flags fail to load
- **ALWAYS** define feature flags in TypeScript interfaces for type safety

### Error Handling Standards
- **ALWAYS** convert technical errors to user-friendly messages
- **ALWAYS** implement rollback mechanisms for optimistic updates
- **ALWAYS** handle RLS policy violations with specific error messages
- **ALWAYS** use toast notifications for consistent error feedback
- **ALWAYS** include proper error logging with context information

### Type Safety Requirements
- **ALWAYS** use Zod schemas for database operation validation
- **ALWAYS** define proper TypeScript interfaces for all data structures
- **ALWAYS** use generic functions for reusable database operations
- **ALWAYS** validate data types before database operations

### Accessibility and Semantic Markup Standards
- **ALWAYS** add comprehensive ARIA support: role, aria-label, aria-labelledby, aria-expanded attributes
- **ALWAYS** use semantic HTML elements (nav, main, aside, header, footer, section)
- **ALWAYS** support keyboard navigation (Enter/Space keys) in interactive elements
- **ALWAYS** add data-testid attributes for DOM inspection and testing
- **ALWAYS** include aria-hidden="true" for decorative icons